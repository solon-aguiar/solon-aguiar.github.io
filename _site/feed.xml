<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://solon-aguiar.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://solon-aguiar.github.io/" rel="alternate" type="text/html" /><updated>2023-08-13T09:37:41+10:00</updated><id>https://solon-aguiar.github.io/feed.xml</id><title type="html">Solon Aguiar</title><subtitle>This is Solon&apos;s personal website. His personal ramblings and thoughts about software, travelling, life, philosophy, psychology &amp; beyond. A way to share and learn. Opinions are personal.</subtitle><entry><title type="html">The parallels of working on cars and software - Part II</title><link href="https://solon-aguiar.github.io/tech/random/2021/02/25/the-parallels-of-working-on-cars-and-software-part-II.html" rel="alternate" type="text/html" title="The parallels of working on cars and software - Part II" /><published>2021-02-25T15:22:00+11:00</published><updated>2021-02-25T15:22:00+11:00</updated><id>https://solon-aguiar.github.io/tech/random/2021/02/25/the-parallels-of-working-on-cars-and-software-part-II</id><content type="html" xml:base="https://solon-aguiar.github.io/tech/random/2021/02/25/the-parallels-of-working-on-cars-and-software-part-II.html"><![CDATA[<p>This is the part two of my series on the parallels of working in cars and software. You can find Part I <a href="https://solon-aguiar.github.io/tech/random/2021/01/04/the-parallels-of-working-on-cars-and-software-part-I.html">in the archive</a>.</p>

<p>In this part I’ll cover some aspects that, for me, are not obvious at first. Almost all of the ideas I’ll list here were revelations that came to me with time - some actually only came to me after I stated writing this series.</p>

<h1 id="methodical">Methodical</h1>

<p>According to the MacOSX dictionary on my computer, “method” means: “a particular form of procedure for accomplishing or approaching something, especially a systematic or established one”. To work on cars, one has to be extremely methodical. This means following a step-by-step procedure to tighten screws, nuts and bolts; to change the oil; to drop an engine; install the bearings; how to align a screw. All of these and many others have to be performed extremely carefully and with attention to detail so that they are accomplished correctly. It is very easy to mess something up. Sometimes it can be even a bit boring how much method you have to follow.</p>

<p>While working on the engine, I was automatically engulfed by any activity that we were performing. From the simply tightening screws in the engine tin to assembling the cylinder heads. These took all of my attention and focus not only because I enjoyed what I was doing, but because that was required in order to do it correctly. Any simple mistake could hinder the performance of the engine in the best case or cause complete failure in the worst. On top of that, one can rarely parallelize the tasks performed while working on a car.</p>

<p>I always dedicated all of my attention to what I was doing to the point that I rarely thought about looking at my phone, listening to music or any other common form of distraction/parallelism that we’re used to on our day to day. Most of the time, even the conversation with Jim had to stop so that we both gave our undivided attention to a task.</p>

<p>For me, the world of software is not very different. While working on a piece of software with my undivided attention always yields the best results. Undivided attention means turning off my cellphone, instant messaging, email etc. These take my brain power off of the task at hand and impact my output. Additionally, for more manual and repetitive tasks, I add another layer to the task: write down a detailed step by step of what I need to do so that I can just follow it instead of coming up with something as I go. This usually frees up my mind to perform the step itself rather than what I need to do next. Being extremely methodical is a way of guaranteeing consistent results.</p>

<p>Some people aren’t so strict and can perform really well while listening to music, answering instant messages or being distracted by other things. That is not how it works for me. I perform a lot better (in terms of quality of the output) when I am able to get into a flow state where I’m completely immersed in a task at hand.</p>

<p>This is perhaps one of the most controversial lessons of this whole series as the shift from parallelization usually instantly leads to the perception of lower throughput of work. I strongly disagree with that. It may seem like the case at first, but a single thread of mental activity usually leads to higher quality and faster work, which, by definition creates more capacity and more importantly, it generates less bugs (and, consequentially, re-work).</p>

<h1 id="unit-and-integration-tests">Unit and integration tests</h1>

<p>A mechanic performs almost as many tests as a software engineer on their day to day. These tests vary from a single unit of the engine, to the interactions of two units and the whole operation of the system. During our rebuild, Jim and I had to measure weight of the pistons to make sure that all four were within five grams of each other; we had to measure the thickness of the shims for the crankshaft; the endplay of the crankshaft + flywheel and many other things. As we moved along in the rebuild, the checks for correct operation of each one of these parts gave us more confidence that the whole system would work correctly. We could have skipped some of these tests to save time, but a badly configured endplay could jeopardize the operation of the engine under certain circumstances and that was not a risk we were willing to take. We needed the best coverage we could get with the tools and time available to us.</p>

<p>I hope that the parallel to the world of software is obvious on this one. We need to test our components individually (unit tests - the same way we measure the weight of the pistons), test the operation of two or more components combined (integration tests - the endplay check which involved the crankshaft, flywheel and its shims) and that the whole system connected works (smoke test - more on that below). The existence of each of these different types of tests has a different “responsibility” in our day to day. If we don’t have confidence that the units that comprise the system aren’t working individually, how can we have confidence and ascertain the correctness of the whole system or parts it?</p>

<p>The goal behind all of this work is to be sure, with the highest degree of confidence that is possible in terms of cost benefit, that what we’re doing is going to work well (or at least according to the specification). There is no point in doing work without making sure the pieces are doing what they are supposed to do. The way I see, tests are an essential part of the work, not extra.</p>

<h1 id="research">Research</h1>

<p>There were times during our rebuild when we didn’t know how to proceed. That often happened because the problem was not mentioned in any of the manuals we were using. In these moments, we had two common avenues: we’d research in online forums or we’d call a mechanic with experience in the Type IV engine to ask for help. One way or another, we always got to an answer (for example, when we didn’t know how to properly and safely remove the pilot bearing).</p>

<p>The same happens in software: we are constantly facing new problems, bugs, investigations. We often have to do our own research (in literature, online, internal manuals etc) and when stuck, rely on others to provide assistance or even act as a <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck</a>. Research teaches us new things and can give us confidence in our judgment. At the very least, it provides us with new ideas.</p>

<h1 id="smoke-tests">Smoke tests</h1>

<p>Once all parts were assembled, the engine was oiled up and in the car, the next step was to fire it up. For Jim and I, this was both a scary and exciting moment. After months of work, everything was in place and ready to go. It was a matter of turning on the key. As exciting as that was, we had to do it safely. Therefore, for the first time we turned the engine on, we did so in a controlled environment: my in-laws garage. It is isolated from all of the other cars (and people) so that we didn’t cause any harm while giving us plenty of room to observe it in use. The idea was to fire it up and let it run in idle in the garage for 15 minutes so that we made sure there were no leaks (of oil, exhaust, gasoline etc.) and that everything was working smoothly. It was quite literally, a smoke test.</p>

<p>In software, smoke tests are a way of making sure the very basic functionalities of the system are working well (the concept of smoke tests actually comes from electronics - hence the name). Not many features are tested in depth, but only the bare minimum that are required for the software to be considered operational. These tests can be automated in a test environment or using a test instance of the system brought up just for this purpose.</p>

<p>In the engine smoke test, we didn’t test for gasoline consumption, oil pressure, temperature, performance at different speeds etc. We just made sure that it turned on and idled fine. The more complete tests would happen later in the process. Similarly, in a software smoke test, one wouldn’t usually test for performance, vulnerabilities etc. focusing mostly on whether the system is coming up well and able to perform some tasks. Although it may seem that this doesn’t add much value, it is a stepping stone to more elaborate exploration done later.</p>

<h1 id="alpha-environment">Alpha environment</h1>

<p>During the rebuild, there were a few delicate steps that, if done wrongly, were going to be extremely hard or time consuming to undo. Dropping the distributor shaft was one of them. The distributor shaft is a piece of metal that, in the bottom part, connects to one of the gears in the crankshaft and in the top connects to the bottom of the distributor. It lives inside the crankcase and it is essential that it is properly in place otherwise the engine will misfire badly. Jim and I were very afraid to mess up this step. An error here would only be detected once we fired up the engine (which meant that we would have put everything back together and in the car again).</p>

<p><img src="/assets/images/engine_in.jpg" alt="Engine in the car" />
<em>The engine in the car (in the garage)</em></p>

<p>Luckily, we had another engine lying around! Since we weren’t doing the work on the engine that we pulled out of the car (remember that I bought an extra engine?), we could practice the process in this spare engine to make sure we got it right. That is exactly what we did. Being able to practice and test our procedure in a test engine, gave us confidence that we knew what to do when we got the new engine.</p>

<p>This can happen mostly (if not all) of the time in the software world. We can (I’d dare say should) practice most procedures in testing environments to make sure that they work correctly. These procedures can be: database migrations, UX changes, feature flags etc. Most importantly, the software itself should be used in testing environments (preferably by more than one person) before going live. Doing so regularly will reduce the number of bugs that make it production as it is used in ways that resemble production.</p>

<h1 id="debugging">Debugging</h1>

<p>Even when mechanics do everything right and according to the manuals, things can still go wrong. Jim and I had followed the many step by step procedures thoroughly and didn’t miss anything. Yet, during the first time that we tried to fire the engine, it didn’t start. A detailed observation and troubleshooting followed. To understand what was causing the issue, we had to observe the system. We had to get as much information as possible in order to devise a strategy to fix it. We came up with a few questions that would help us: Was the timing adjusted? Was the ignition firing? Was the engine turning? Was the coil getting current? Were the smart plugs connected? Were the spark plugs getting current? Does a visual inspection of the whole system show anything wrong?. When we successfully answered one of those, we moved one step closer to finding the component that was at fault. Once we found that component, we’d follow the specified manual procedures to either fix the component or replace it completely.</p>

<p>We used a timing light to see if the spark plus were getting current and it showed that they weren’t. That discovery let us narrow down the issue to the electrical system and upon close inspection of the connections and the wires I realized that one of the wires to the distributor hall sensor was broken. That explained why the engine turned, but not fired and why the spark plugs weren’t firing. We promptly soldered the wire and the engine started! It sounded and worked beautifully after that fix.
In my day to day investigating bugs, I often follow a similar process. Whenever an issue is reported (either by a user or automatically) on a system, I narrow down the possible location of the issue by looking at metrics, logs, reports etc. Using all of the data available (or gathering new data if it is not), is the only way that I can properly find the cause for a problem. I cannot just out of thin air come up with a theory of what is wrong. I have to look at the clues available.</p>

<p>Unlike the world of software, however, in cars I cannot create an automated test to verify the fix for my problem. If a problem happens again, I have to start the troubleshooting procedures from scratch to determine the root cause. In this sense, software engineers are luckier than mechanics.</p>

<h1 id="escalating-to-another-team">Escalating to another team</h1>

<p>The last parallel that I want to bring up is escalations. After firing up the engine, Jim and I noted an oil leak coming from one of the oil galleys that the machinist had worked on. This was a piece of the crankcase that he had drilled and tapped to avoid a problem that happens on these old engines during cold weather when the old galley plug just shoots out of the crankcase if you’re curious. This leak was due to the plug that he had used - it didn’t seal the hole well, so not only oil was leaking through but also the oil pressure was dropping at times. This was bad and extremely frustrating news, because it delayed the completion of the project and it was not caused by something that we did wrong. After allowing ourselves sometime to complain and be angry about it, we set out to fix it.</p>

<p>Our first line of action was to try to fix the plug ourselves. We debated the problem and researched our options. In the end, I bought a couple of new plugs and we tried them with no luck - the leak still happened. Next step was calling the machinist, since he had worked on the galleys. He suggested using epoxy around the plug in order to seal the hole - we tried that and no luck as well. With all of our own options exhausted, we took the car back to the machine shop where they took the engine out and fixed the issue themselves as part of their warranty for having initially worked on that part of the engine.</p>

<p>In software, we tackle hard problems all of the time. A lot of the times, problems that weren’t caused or created by us. Sometimes solving these issues are beyond our knowledge or abilities and we need to call for help. This can be frustrating, especially after spending so much time and effort on an issue, but ultimately the proper operation of the system is the goal. Although admitting that I cannot (or don’t know how to) do something is not always the most fun thing to do, I see that as an opportunity to learn from someone with more knowledge than me. Voicing my own ignorance opens many more possibilities for me as it frees me to learn.</p>

<p>—</p>

<p>I hope that you’ve enjoyed the comparisons between working on cars and the world of software.</p>

<p>After finishing the engine and some other minor improvements on the car, I sold it. It was never my goal to sell the car when I started the project, but after it was back with me I realized that I didn’t like driving stick shift anymore (I had my fair share of it already in my life). I sold it in 2020 and got a newer Vanagon version with an automatic transmission. Now I don’t need to shift gears anymore.</p>]]></content><author><name></name></author><category term="tech" /><category term="random" /><summary type="html"><![CDATA[My last thoughts on how working on cars compares to software]]></summary></entry><entry><title type="html">The parallels of working on cars and software - Part I</title><link href="https://solon-aguiar.github.io/tech/random/2021/01/05/the-parallels-of-working-on-cars-and-software-part-I.html" rel="alternate" type="text/html" title="The parallels of working on cars and software - Part I" /><published>2021-01-05T12:56:00+11:00</published><updated>2021-01-05T12:56:00+11:00</updated><id>https://solon-aguiar.github.io/tech/random/2021/01/05/the-parallels-of-working-on-cars-and-software-part-I</id><content type="html" xml:base="https://solon-aguiar.github.io/tech/random/2021/01/05/the-parallels-of-working-on-cars-and-software-part-I.html"><![CDATA[<p>A little over a year ago, in July 2019, I decided to buy an old beat up Volkswagen type IV engine and rebuild it from the bottom up. The small print on the corner is that, at the time, I had never worked on car engines. Better (or worse in this case), I had never worked on anything related to cars - not even changed a tire.</p>

<p>The desire to get my hands dirty and learn about cars along with the stupidity, naiveté and some free time got me started on the endeavor. Despite having a basis to start, after all the famous <a href="https://www.amazon.com/dp/1566913101">idiot book</a>, which I had bought a few weeks earlier, described the process in layman terms, I still didn’t feel confident enough to do it all on my own. I knew that there was room for catastrophical error, so I was looking for a safety net.</p>

<p><img src="/assets/images/engine-crankshaft.jpg" alt="Engine crankshaft on our working table" />
<em>The crankshaft on our working table</em></p>

<p>Luckily, my friend Jim, who not only had Volkswagens in the old days, but also worked on his cars himself, volunteered to help me out - a decision that to this day he probably regrets. Helping out is an understatement. Jim spent dozen of hours in cold humid garage with me through Seattle’s autumn and winter, being an essential figure in the whole process. Truth to be told, the rebuilding of the engine really was an accomplishment of us as a team. I couldn’t have done without him.</p>

<p>Looking back at that whole experience, a lot of parallels can be drawn about the world of software and working on cars. I will discuss some of those throughout this post. These, by no means, are indisputable truths. Rather, it reflects my thoughts on how ideas and practices from these seemingly distinct domains surface in each area.</p>

<p>Buckle up and enjoy the ride … (mandatory car pun).</p>

<h1 id="the-project">The project</h1>

<p>This parallel is obvious, but worth making it clear. The goal was to rebuild the engine - just the engine and nothing else. Engine, in this context, means the long block, which is comprised of the cylinder heads, pistons, connecting rods, bearings, crankshaft, camshaft (all of which are inside the case), pushrods and valves. If these terms are alien to you, don’t worry. They don’t have any relevancy to the rest of the post.</p>

<p>The scope, then, was clear. We were focused on the engine. We were not going to touch any other part of the system, like suspension, transmission, fuel lines, brakes etc. Limiting the scope reduced the number of moving parts and allowed us to trust that the whole system was working prior to any change - after all the car was fully functional and drivable before the engine rebuild.</p>

<p>Like a software project, focus helps achieve better results. It is easy to scope creep and let other tasks pile up (“hey, since we’re at it, why not replace the brakes?”). While these could be perfectly valid improvements and add-ons, the smaller the change is, the faster we can get feedback. With faster feedback, we can quickly validate that we’re delivering the desired functionality.</p>

<p>Driving (another pun) the analogy even further, one could argue that I could have done an even more focused work. I could, say, have replaced one cylinder head, fired up the engine to see it works (feedback) before going to the next task. This is a great idea, however, the world of of car tinkering is a little bit more complicated than that, especially with regards to the deployment process of an engine as you’ll read in the next section…</p>

<h1 id="the-deployment-process">The deployment process</h1>

<p>There’s no way to change the engine while the car is running. Even if there was (while the car is rolling down an extremely long hill?), it would be too risky and inconceivable for my (or Jim’s) abilities. This is an area that the world of software is way better equipped to do.</p>

<p>Blue-green deployments are the norm in all respectable software systems today, so it is normal to take it for granted. Past are the days when we had to take systems down for “maintenance” during periods of low load. Nowadays, we can deploy hundreds of times a day without any customer impact.</p>

<p>Even when completely reworking parts of a system (say, in a new tech stack), assuming we maintain the interface unchanged (aka no backwards incompatible change), we can completely replace parts of a system while it is still running. Unfortunately, for Jim and I, we couldn’t do that with our engine. In conclusion, there was going to be downtime. The car had to be parked in the garage and not moved for as long as the engine was out (luckily I had another car to drive around - especially to go get the new parts!).</p>

<p>As I said in the previous section, we could also have reduced the scope of change per unit of work. We could have replaced one part at a time to get feedback on individual components. The sole nature of changing an engine part, however, would make the timeline of the project explode exponentially. If we were to follow this release process, we would have to jack up the car, drop the engine, disassemble all of the peripherals, replace the specific part, assemble the peripherals, put the engine back in the car, remove the car from stands and fire it up. This would be easily a 20-hour process per part - and we had dozens of parts to replace. The trade-off was clear and easy to reason upon. We didn’t even have to discuss it - we were going to replace the whole engine at once and risk failure. Even if it failed and we had to remove it to fix it, it would take less time than to do it one part at a time.</p>

<h1 id="the-tools">The tools</h1>

<p>This is also another obvious parallel - we need tools for working on cars and on software. For the engine rebuild, I started with the set of tools that I had (hammer, crescent and open ended wrenches) and throughout many weekends had to get familiar with a whole new myriad of tools: from torque wrenches all the way to digital calipers. From rustic wood blocks used to bang on metal, to voltmeters used to measure current in the fuel injection circuit. From fine bolt threads to silicon gaskets. I even had to get acquainted with a lot of new vocabulary that I had never realized existed.</p>

<p>In software engineering it is no different. We start with some basic tools such as our favorite IDE or programming language and start to pick up new ones along the way: new programming languages, frameworks, testing tools, linters, compilers, version control, logging, operating system etc.</p>

<p>As with most tools, no matter how good the tool in front of you is, if you don’t know how to use it properly, it won’t help you much. I had to learn the best technique to use a torque wrench, how to get an accurate reading out of a digital caliper, how to use a voltmeter, how to properly apply a gasket etc. The same holds true for software. If you don’t know how to write good tests, that new shiny testing framework won’t help you much. If you don’t know how to write good logs, the log search tool won’t bring any benefit.</p>

<p>It could also be that you didn’t even know that a tool for a specific job existed (like I didn’t know of digital calipers). A lot of the time, it means that you never had a need or it, but it could also be that you just reinvented the wheel (another car pun). One way or another, learning how to best use it will probably benefit you in the short and long term, so there’s no reason not to do it.</p>

<h1 id="the-bibliography">The bibliography</h1>

<p>Even the most seasoned mechanic will maintain a set of manuals in their shop. These are used as reference for complicated procedures, measurements, part numbers etc. They are essential in any mechanic’s toolkit and it wouldn’t be an understatement to consider them essential.</p>

<p>Not knowing that, but rather admitting my ignorance on the subject, I was equipped with three different manuals on the engine that I was working. My idea was that I would have as much information as possible when I got stuck (note that I knew I was going to get stuck, I just didn’t know at what moment). Looking back, I am completely confident to say that I wouldn’t have finished the work without them (even with all of Jim’s immense knowledge). Each one of these books provided valuable information that complemented each other when one was lacking important details.</p>

<p>When these books failed to contain a need procedure or troubleshooting guide, I resorted to the community (which is very friendly and helpful in the VW world) as a source of information and ideas.</p>

<p>The importance of good documentation is not unknown to a software practitioner. One commonly uses many sources of information to assist them on their daily jobs: from reading books on tools and techniques to using StackOverflow to find an answer to that lingering question or exception error code. As computer programmers, it can often be tedious and cumbersome to write good documentation. An argument that I’ve often used in the past for not writing good documentation is that good code documents itself. While I still believe on that adage, I realize that we don’t always have the time to dig into the code of a library or a dependency that we use.</p>

<p>I think that most of us agree that well written documentation is extremely important to help us do our jobs well. Writing documentation and manuals is a skill often overlooked, but that I’ve found to be very important and hard to do well. The way I see it, if no one uses the code that I write, then what is the point of writing it? Documenting is step in getting your code used.</p>

<h1 id="pairing--mentoring">Pairing &amp; Mentoring</h1>

<p>No novice mechanic starts doing all the work by themselves right away. It takes two years for a novice <a href="http://www.ase.com/">ASE</a> student to be certified. During this time your work is accompanied by more senior mechanics and you do have to pass a test at the end of the period.</p>

<p>Although not related to the ASE at all, my work on the engine followed a similar mentorship pattern. As Jim had a lot more experience with engines and cars in general, he guided me throughout all of the process, often taking the lead on the very most delicate steps (such as dropping the distributor shaft!) after we discussed and agreed on the path forward. He taught me a lot - from the simple difference about bolt thread types, through the best way to use a torque wrench and to the best way to tighten the cylinder heads. Meanwhile, though not teaching him much other than my awesome jokes, I was (or at least like to think I was) a good source of ideas and someone to verify the work and procedures.</p>

<p>The first full time job that I had as a computer programmer was at a consultancy company called <a href="http://thoughtworks.com/">ThoughtWorks</a>. At ThoughtWorks we always paired programmed - by always, I really mean 100% of the time. For a lot of people, the idea of two engineers pair programming all of the time is a waste of time and resources. After all, you could double the throughput by having the two people working separately. You’d have twice as much code produced!</p>

<p>The problem with that mindset of lines-of-code-written as a measure of efficiency is that with double the throughput, you double the bugs! As most of us know, software maintenance incurs more costs than actually software development, which makes fixing bugs more expensive than producing them! That is the rationale behind pair programming: an extra pair of eyes can catch issues before they are live and causing issues in production.</p>

<p>Another more subtle benefit of pair programming is career development. Especially for more junior engineers (or mechanics), having the time and opportunity to work alongside a more seasoned practitioner is of invaluable value. One can learn common practices and techniques,  that would normally take months or years to develop by themselves. On top of that, by working with more experienced people, rookies can often feel more empowered to take risks or question the status quo, as the new thoughts can often be discussed in the pair before being brought up to a wider audience. The constant mentorship, in my point of view, is not only valuable in technical terms, but also on personal terms, as it can be (assuming that the relationship is healthy) empowering.</p>

<p>Realizing those benefits, but not willing (or not being able) to sacrifice programmers time so much, a lot of companies nowadays use code reviews as part of their software development cycle. The idea is that it yields similar benefits whilst still allowing programmers to work on separate tasks. In my experience this can be true: when people (the rookie and the experienced) realize that offline mentoring takes more effort than just being side by side and do spend their time and attention on the process, it is very beneficial; when one side or another take it for granted, then they’re setting themselves up for failure.</p>

<p>As I said earlier, Jim and I paired most of the time. On some occasions, when he wasn’t able to join me, Jim reviewed my work at a later time. The pairing was mostly valuable in the first few weeks when a lot was new and unknown. The reviewed process was more common in the end, when I was more confident on my abilities.</p>

<p>—</p>

<p>I have more to share! This post was already getting very large, so, like any good story, I decided to break it down into a trilogy.</p>

<p>Stay tuned for part two, where I will cover some parallels between the work of software and the word of cars that, at least for me, are not as obvious as the ones listed here.</p>]]></content><author><name></name></author><category term="tech" /><category term="random" /><summary type="html"><![CDATA[My thoughts on how similar working on cars and software projects can be]]></summary></entry><entry><title type="html">The tech interview process</title><link href="https://solon-aguiar.github.io/tech/interview/2018/10/22/tech-interview.html" rel="alternate" type="text/html" title="The tech interview process" /><published>2018-10-22T09:11:00+11:00</published><updated>2018-10-22T09:11:00+11:00</updated><id>https://solon-aguiar.github.io/tech/interview/2018/10/22/tech-interview</id><content type="html" xml:base="https://solon-aguiar.github.io/tech/interview/2018/10/22/tech-interview.html"><![CDATA[<p>For better or for worse, I’ve been through a lot of different interview processes at tech companies to the point that I consider myself experienced in interviewing for jobs. It doesn’t mean that I am good at it, it just means that I understand the processes relatively well.</p>

<p>I’ve interviewed at a wide range of tech companies: from Fortune 100 to start-ups and I’ve got to experience a plethora of different ideas on what is thought to be the best way to assess talent. I’ve seen well structured processes, some that try to evaluate different types of skills and, unfortunately, a lot that are very confusing and not inclusive. All of them have weaknesses. Some a lot more than others.</p>

<p>A lot is said about the lack of diversity in tech. I believe that it is a huge problem and I sincerely believe that a lot of it has to do with the fact that tech hiring is broken in so many ways. I list some of what I think are the reasons for that below.</p>

<p>Disclaimer #1: my track record is roughly one offer at every 3 companies I interview with - I am not counting the ones I applied and was rejected even before one interview - all of this, for my sadness, has showed me a wide share of rejection emails. I’ve applied for positions that required a lot of the experience that I have and for positions that I barely match any of requirements. I don’t know if this is a good of a bad track record, but that doesn’t invalidate my thoughts or observations. Also, they don’t come from any grudge I hold, and some of them are even from companies I’ve gotten offers for.</p>

<p>Disclaimer #2: Even though some of the time I’ve disagreed with the final decision of a rejection, I have never believed that any rejection was for any reason other than my technical skills, such as bias or prejudice. I believe that everyone I interviewed with has been solely focused on my demonstration (or lack) of abilities to do the job.</p>

<p>Disclaimer #3: It is important to notice that in some cases I am generalizing. Not all the situations happen like that all the time, but at least one of them are common in each process I’ve been through.</p>

<p>I believe it is important to discuss this. Discussing problems is the only way to search for solutions. It allows us to recognize different perspectives, see gaps that we didn’t see before and open our mind.</p>

<p>–</p>

<h1 id="and-the-common-tech-recruiting-problems-are">And the common tech recruiting problems are…</h1>

<h3 id="the-shadow-recruiter">The shadow-recruiter</h3>

<p>A lot of the time, the first step in any process is a conversation with a recruiter. This person’s role in the process is to be the first layer of filtering and also be your point of contact throughout your time interviewing.</p>

<p>Most of the time, the conversation looms around your interests, your experience and what you’re looking for. It can also go through the dreaded salary expectations question. The recruiter will say a bunch of buzz words while waiting to hear others back (to see if there is a “match in expectations”).</p>

<p>For companies, it is a matter of saving precious engineering time with candidates that aren’t worth it. For candidates, it is mostly a waste of time except in the rare cases the recruiter has some information that isn’t on the company’s website (which is rare).</p>

<p>I call this problem “the shadow recruiter” because the during this first conversation, the recruiter doesn’t have any useful information for the candidate. And, after the other interviews start, they just vanish. Many many times, in many different companies, the recruiters have turned out to be unresponsive with updates, feedback or any other useful information. They just don’t provide you with information. You’re left in the dark until you reach out. It is a common pattern that I constantly have to reach out one or two times before getting any update. This is terrible and frustrating candidate experience.</p>

<h3 id="the-all-in-be-perfect-approach">The all-in-be-perfect-approach</h3>

<p>Ah, the “no false positives”… That is surely one of the most frustrating things in the tech interview world. Companies devise a process to assess candidates in many areas and in the slightest sign of doubt, they just let the candidate pass. It doesn’t matter if the sign was significant, occurred only once or in all interviews. A single slip from the candidate after 6 or 7 hours of interviewing is enough data for a company to decide that they aren’t fit for the job.</p>

<p>Well, that just makes sense, right? All of my current employees can be grilled by people that they don’t know for 5 hours straight and not make a single mistake. Why can’t you, dear candidate? Making a mistake in this hour-long interview shows me that you’ll do the same while you’re doing your job here, which will make me waste my time and money. I’ll just disregard the other 6 hours you spent with us. Therefore, thank you for your time, good bye. Maybe try again next year?</p>

<p>I think that people who devise these strategies or believe this have not gone through the very own process they designed. Interviewing is stressful and hard for almost everyone. Your career, and a lot of times your future, is on the line. You are going to make mistakes. And that is normal. Everyone makes mistakes while doing their job. I do that all the time today. But why is it so harmful during an interview? Why one bad interview in 7 is enough data to show that you’ll underperform in the job? Is this really the case or are we just scared or standing by our thoughts?</p>

<h3 id="the-non-diverse-panel">The non-diverse-panel</h3>

<p>Everyone wants to increase diversity, yet no one strives to make it easy to do so. Even when they have a shot at it, they fail. It is so hard, not to mention harmful, to go through a process and only see people that lookalike (and most of the time different from you). Interviewers will have unconscious biases that can dictate what they think about and judge of you. That can undermine your candidacy and chances of success.</p>

<p>In order to promote diversity and inclusion, companies should promote D&amp;I in their interview panel. They should have panels that are diverse and bring different perspectives and ideas to the table. That will make the candidates feel welcomed by seeing diversity and, more importantly, reduce the effect of biases in evaluation.</p>

<h3 id="the-no-feedback-policy">The no-feedback-policy</h3>

<p>As a candidate that fails a process, there is very seldom room to know what you were missing. A lot of the time, companies provide no feedback on their evaluation to you. I understand that for legal reasons they can’t just share what they think and I’m not preaching for that. I do believe, though, that if we don’t provide any feedback we’re not making any progress towards giving more people chances. If people don’t know specifically what they have to get better at, how can they have a chance at it?</p>

<p>I admit that not everyone is keen of receiving evaluation. I think, though, that any time someone reaches out to get feedback, companies should promptly and respectfully provide candidates with useful information that they can use to address their gaps. I see that as a responsibility of the companies. After all, candidates have invested so much of their time in going through the process that the minimum the companies can do is provide them with some thoughts. I believe that there is a way of doing that without being liable for lawsuits and not being generic as “get better at algorithms and study data structures”.</p>

<h3 id="the-i-do-not-need-to-respond-anymore">The I-do-not-need-to-respond-anymore</h3>

<p>Another very frustrating pattern is being left in the dark after a final decision is made. Any time I get a decision for good or bad I send an email back with comments and or questions and most of the time I never hear back in the case of rejection. It is as if I have a contagious disease and people at that company don’t want to talk to me any more after they realized I am not perfect for their position. They don’t want to “waste” time with me anymore.</p>

<p>The funny thing is that any time before the final decision, they are all happy and cheerful in answering. Things just suddenly change when they decide that it’s a no go. Now, you’re not worth their attention anymore. This is really hurting.</p>

<p>We’re all humans. We are bond to contact people and to have feelings. Especially when we invest so much time in a process. It is really easy to just hide behind an email inbox, but we don’t have to be like that. Be human too and at least acknowledge the other person’s communication, even if it is just to say thank you and move on. Don’t leave them hanging. That hurts and will surely impact their view of your company for the future.</p>

<p>–</p>

<h1 id="and-what-is-the-perfect-process">And what is the perfect process?</h1>

<p>There likely isn’t a perfect process. Evaluating people is hard and not a precise science. From the moment you have employees evaluating candidates, you’re subject to biases and flaws. It is our nature. And the process that is thought to address this a lot of the time doesn’t. More importantly, processes aren’t perfect. They are subject to failure too and we shouldn’t shy away from noticing and voicing that. We shouldn’t hide behind the flag of a process as way to protect ourselves from making a hard or disagreeable decision. Trusting the process is the easy thing to do, but can often also be the wrong one.</p>

<p>I believe that we can get better. Addressing the issues I listed above will surely make processes more humane and somewhat just. Do however you want to do: algorithmical questions, small code problems, just talking or a mix of all of that. All of these ideas of measuring one’s knowledge are subject to the flaws I listed above. Being aware of that and constantly measuring it will help you make sure you’re on track.</p>]]></content><author><name></name></author><category term="tech" /><category term="interview" /><summary type="html"><![CDATA[The thoughts behind many interview processes I've been through]]></summary></entry><entry><title type="html">Exponential Back-off</title><link href="https://solon-aguiar.github.io/design-pattern/backend/2018/09/18/exponential-backoff.html" rel="alternate" type="text/html" title="Exponential Back-off" /><published>2018-09-18T09:36:00+10:00</published><updated>2018-09-18T09:36:00+10:00</updated><id>https://solon-aguiar.github.io/design-pattern/backend/2018/09/18/exponential-backoff</id><content type="html" xml:base="https://solon-aguiar.github.io/design-pattern/backend/2018/09/18/exponential-backoff.html"><![CDATA[<p>Following my post on <a href="https://solon-aguiar.github.io/design-pattern/backend/2018/09/06/circuit-breaker-pattern.html">Circuit Breaker</a> I will now cover <em>Exponential Back-off</em>. This pattern can be used along with <em>Circuit Breaker</em>, but can also be used without it. In general, for any distributed system - especially one that operates at high scale, retrying failed remote requests with an exponential back-off is a good idea.</p>

<h1 id="the-problem">The problem</h1>
<p>Let’s elaborate on the same <strong>AccountSystem</strong> example from the last post. As we saw, that system requests data from the <strong>UserAccountsDB</strong>, which is a hard dependency as without the data, the <strong>AccountSystem</strong> cannot do much computation.</p>

<p>Since we’re working in a distributed system, we know that the remote request to the database can fail for a multitude of reasons: network blip, data loss, timeout while opening/re-establishing connection, process re-started, full request queue etc. To make our system more resilient and avoid throwing errors to our callers every time something happens we decide to retry a request every time it fails (we’ll discuss the downside of this later). This will decrease our error response rate and make everyone happier.</p>

<h1 id="the-solution">The solution</h1>

<p>To implement retries, we change of our main application logic to look something like this (pseudocode for a hypothetical 3 retries implementation):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">database</span> <span class="o">=</span> <span class="no">UserAccountsDB</span><span class="p">.</span><span class="nf">new</span>

<span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
   <span class="n">data</span> <span class="o">=</span> <span class="n">database</span><span class="p">.</span><span class="nf">read_user_data</span><span class="p">(</span><span class="s2">"user_id"</span><span class="p">)</span>
   <span class="k">break</span> <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="no">Nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We make the change, test and see that this code works. It retries each failed request up to three times. Great, we solved the problem… but created another. The problem with this approach is that it doesn’t give time for whatever was causing the request to fail to be fixed - either by itself of via external interference. In other words, it doesn’t “give” time for the system to recover. It simply keeps retrying until it succeeds or until it reaches the end of retries as we don’t want to keep retrying forever.</p>

<p>What can we do to tackle this?</p>

<p>We can just wait a little bit! Let’s add a little wait (let’s say 200 ms) after each failure to give the system some time to recover from whatever is causing it to fail. Our code becomes this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">database</span> <span class="o">=</span> <span class="no">UserAccountsDB</span><span class="p">.</span><span class="nf">new</span>

<span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
   <span class="n">data</span> <span class="o">=</span> <span class="n">database</span><span class="p">.</span><span class="nf">read_user_data</span><span class="p">(</span><span class="s2">"user_id"</span><span class="p">)</span>
   <span class="k">break</span> <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="no">Nil</span>
   <span class="nb">system</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now every time a request fails we wait a little bit (in this case I chose 200 ms arbitrarily) and then retry. The advantage of this is that, empirically - not mathematically, it is more likely that subsequent requests will succeed after a failure because we waited a little bit.</p>

<p>However, this implementation also has a problem. The problem is a little bit more subtle and normally only surfaces at large scale systems under very specific conditions (that aren’t that rare as I’ll tell you later in this post).</p>

<h2 id="at-scale">At scale</h2>

<p>Let’s imagine that our <strong>AccountSystem</strong> is running in production. Since we have a very successful company, we get a lot of traffic and have to scale it to 600 hosts to accommodate all the traffic. All of these hosts connect to the <strong>UserAccountsDB</strong> to read user data. Now let’s imagine that for some unfortunate reason, the database goes down. What will happen to our <strong>AccountSystem</strong>? Since earlier we decided to make our system resilient via retries, it won’t just start throwing errors at the callers. It will first retry failed requests. This is great until it isn’t.</p>

<p>All of our 600 hosts have received failures from the database when it went down, so all of these hosts have started to put their threads to sleep in order to retry those requests later. Until that point, nothing bad, everything working as we designed. But what happens when the <strong>UserAccountsDB</strong> comes back up? All of the “pending” requests (which can be a lot more than 600 assuming a system that handles more than one request at a time) will be retried in a very short span of time - possibly at the same time!</p>

<p>Since the failures started happening at around the same moment, the instances of the <strong>AccountSystem</strong> decided to “sleep” on those in hopes that they would be fixed. When the database came back up and the system “woke up”, it started to retry everything that had been pending. Since the hosts most likely put the threads to sleep around the same time, all requests were retried simultaneously (or within a few seconds apart). This is potentially catastrophic for the database.</p>

<p>Most of the time, the databases aren’t scaled or ready to receive this massive load of requests (and for legitimate reasons!). Normally, databases don’t have to match the scale of the systems that lives in front of them because they don’t take all the load that those receive (obviously this assumption doesn’t hold true in all the cases - it is a generalization of my part). Therefore, when all the requests are retried, the database can be overwhelmed and either perform really badly or even go down (often aggravating the problem itself). It can become a disastrous situation that requires a lot of manual work to be addressed as it keeps breaking itself.</p>

<p>The key problem here are the simultaneously retried requests. To address this issue, the <em>Exponential Backoff</em> comes into play. The idea is that each time a request fails, it “tells” us something about the environment. Basically, the more times the same request fails, the more we wait before the next retry, as previous errors indicate that something is not working well. Our pseudocode becomes something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">database</span> <span class="o">=</span> <span class="no">UserAccountsDB</span><span class="p">.</span><span class="nf">new</span>

<span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
   <span class="n">data</span> <span class="o">=</span> <span class="n">database</span><span class="p">.</span><span class="nf">read_user_data</span><span class="p">(</span><span class="s2">"user_id"</span><span class="p">)</span>
   <span class="k">break</span> <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="no">Nil</span>
   <span class="nb">system</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">exponential_backoff</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The implementation of the <code class="language-plaintext highlighter-rouge">exponential_backoff</code> can vary on the application, but in general it can be something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exponential_backoff</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="o">+</span> <span class="mi">100</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The idea is that we have a base value (in this case 100) and that we randomly wait a few extra milliseconds after each failure (hence the power operation). The random factor is used to avoid that all different requests retry at the same time (situation I described above). Different applications have different ways of implementing the back-off calculation itself (some deal with the base values differently, want to guarantee randomness etc.), but that is out of the scope of this post.</p>

<p>With this implementation, when the database starts failing and the requests go to sleep, they will be awaken at different times, which will avoid hammering the database with a big number of requests. Some requests can and will be retried simultaneously, but due to the randomness factor the number won’t be as high as before. This will allow our system to gracefully come back up.</p>

<h1 id="the-downside">The downside</h1>

<p>Like everything in life, <em>Exponential Backoff</em> has a downside. A few of them are worth mentioning:</p>

<ol>
  <li>Each request that has a failure can take potentially longer to complete: the system might spend unnecessary time waiting before retrying a request. Let’s look at an example: say that we started retry #2 for 3 seconds at t0. Imagine that the database came back at t1. Since we’re waiting until t3, it won’t be until that time that the system will be retry and succeeded on the pending request. As you can see, the system wasted 2 seconds.</li>
  <li>The code gets more complex: Now every retry requires a calculation before it goes to sleep. Our code got a little bit more complex and can be hard to test if you don’t inject the dependencies correctly.</li>
</ol>

<p>It is a trade-off. Sometimes the resilience is worth it sometimes it isn’t. It depends on your system.</p>

<h1 id="in-practice">In practice</h1>
<p><em>Exponential Backoff</em> is a simple solution to a common problem in any computational system. However, you can’t take its usage for granted. In my industry experience I’ve seen real big production issues in Fortune 500 companies that could have been avoided just by using a simple back-off strategy. Each of these failures cost a lot of money and reputation for these companies.</p>

<h1 id="coming-up">Coming up</h1>
<p>I’ll continue on this series of patterns for system design. Next time I’ll talk about using queues for buffering and processing.</p>]]></content><author><name></name></author><category term="design-pattern" /><category term="backend" /><summary type="html"><![CDATA[The Exponential Back-off is pattern for retrying failed computations.]]></summary></entry><entry><title type="html">Circuit Breaker for higher availability and reliability</title><link href="https://solon-aguiar.github.io/design-pattern/backend/2018/09/07/circuit-breaker-pattern.html" rel="alternate" type="text/html" title="Circuit Breaker for higher availability and reliability" /><published>2018-09-07T07:36:00+10:00</published><updated>2018-09-07T07:36:00+10:00</updated><id>https://solon-aguiar.github.io/design-pattern/backend/2018/09/07/circuit-breaker-pattern</id><content type="html" xml:base="https://solon-aguiar.github.io/design-pattern/backend/2018/09/07/circuit-breaker-pattern.html"><![CDATA[<p>The <em>Circuit Breaker</em> pattern is a very useful pattern to improve reliability and availability of a back-end service or micro-service. The idea behind it is actually quite simple: if a system depends on another system (be this latter one a database, remote or distributed file system, back-end etc - any type of remote system that requires a connection), it can keep track of the state of that connection and take immediate action when that dependency is down or not functioning properly in order to alleviate resources.</p>

<p>An example will make it more clear. Let’s say that the <strong>AccountSystem</strong> makes requests to the <strong>UserAccountsDB</strong> in order to read all user data and respond with the user’s subscriptions. Clearly, the database is a requirement for the account system to work properly. If this database is not accessible then there’s not much the <strong>AccountSystem</strong> can do with every request. Therefore, it is a good design pattern for the <strong>AccountSystem</strong> to keep track of the state of that connection and make sure it only tries to fetch user data when it knows it can get the valuable information. In cases when it knows that the connection is not working, it can just reply an error to the caller. See the diagrams below:</p>

<p><img src="/assets/images/cb_connection_ok.png" alt="Connection Ok" />
<img src="/assets/images/cb_connection_not_ok.png" alt="Connection Not Ok" /></p>

<p>This short circuited response allows the system as a whole to free up resources. If the <strong>AccountSystem</strong> still tried to fetch the user’s data, it would use more of its own and the caller’s CPU time as well as network bandwidth. By not making the call it knows that can’t be fulfilled, it saves cpu clocks, bandwidth and time. A client of this service can quickly act on that error response however it deem necessary.</p>

<p>Another benefit of this approach is that whenever the database system does become available, then it won’t likely be overflowed with outstanding requests from the <strong>AccountSystem</strong>, thus reducing the availability risk.</p>

<p>While the idea behind the <em>Circuit Breaker</em> pattern is simple, it’s implementation can be a bit tricky (even though you can find some code on Wikipedia etc.). The thing is that maintaining the state of this connection (or many others in case your system depends on more than 1 remote system) is not trivial. You have to be careful with the transitions between those states. A few interesting questions to ask yourself:
When do you mark a connection as down? It is not a really good idea to do at every error as those can happen due to network and software glitches etc.
What is the time period to consider a connection down? X errors in Y seconds is enough? What are acceptable values of X and Y that will give the benefit of the short circuit and not cause too many false positives?
Once a connection is marked as down, how often do you check for its availability again, so that you can re-open the circuit? This is critical to be able to fully respond to requests again. When thinking about this one, it is specifically important to think how you keep retrying. A good alternative is using exponential backoffs, which will be the topic of my next post.</p>

<p>The <em>Circuit Breaker</em> pattern is very useful in the case of hard dependencies on other systems, but not the only case where it can be used. It can also be successfully applied in cases when the dependent system is not critical (such as a system that gives you updated weather forecasts in your exercise app). While up-to-date data is desired in all scenarios, some systems can tolerate stale data (even with a warning to the user) and continue to function properly. The <em>Circuit Breaker</em>, in this case, will help free up resources, as said before, and reduce request time.</p>

<p>Note that using the pattern will incur more complexity and possibly add some overhead to each (or some - depending on how often you check it) operations. It can also cause the whole system to take longer to “realize” the dependency is back (depending on how you check for the connection again).</p>

<p>As I said, using the <em>Circuit Breaker</em> improves reliability and availability. It does so because it makes your system more resilient to errors. In most cases the benefits outweigh the drawbacks and make it a good idea to use it.</p>

<p>While using a <em>Circuit Breaker</em>, it is generally a good idea to use an <em>Exponential Backoff</em> for testing the health of the dependent connections. Exponential Backoffs will be the topic of my next blog post.</p>

<p>Stay tuned!</p>]]></content><author><name></name></author><category term="design-pattern" /><category term="backend" /><summary type="html"><![CDATA[The Circuit Breaker pattern is a very useful pattern to improve reliability and availability of a back-end service or micro-service.]]></summary></entry><entry><title type="html">Welcome to my new website!</title><link href="https://solon-aguiar.github.io/about/blog/2018/09/06/welcome-to-my-website.html" rel="alternate" type="text/html" title="Welcome to my new website!" /><published>2018-09-06T08:04:44+10:00</published><updated>2018-09-06T08:04:44+10:00</updated><id>https://solon-aguiar.github.io/about/blog/2018/09/06/welcome-to-my-website</id><content type="html" xml:base="https://solon-aguiar.github.io/about/blog/2018/09/06/welcome-to-my-website.html"><![CDATA[<p>This is my new website. It is built on jekyll and hosted on github pages. It is a simple yet powerful and extensible set up.</p>

<p>I plan to use it as a way to share some of my personal thoughts and whatever interesting topics (in my field of work or not) I feel good about writing.
You shouldn’t expect scheduled updates. Even though I plan to be dilligent about writing, I won’t just write for the sake of writing, so updates will come as I find interesting things to write about.</p>

<p>The first series I plan on writing about is about patterns for reliable backend systems (or microservices). Stay tuned!</p>]]></content><author><name></name></author><category term="about" /><category term="blog" /><summary type="html"><![CDATA[This is my new website. It is built on jekyll and hosted on github pages. It is a simple yet powerful and extensible set up.]]></summary></entry></feed>